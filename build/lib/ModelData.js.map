{
  "version": 3,
  "sources": ["../../src/lib/ModelData.ts"],
  "sourcesContent": ["/**\n * Model class to hold the byte buffer with the protocol data together with the IP address,\n * to which the data is sent.\n */\nexport class DataToSend {\n    /**\n     * Constructor of the class.\n     *\n     * @param data The byte buffer holding the data to send.\n     * @param ipAddress The IP address, to which the data is sent.\n     */\n    public constructor(data: Buffer, ipAddress: string) {\n        this.data = data;\n        this.ipAddress = ipAddress;\n    }\n\n    public data: Buffer;\n    public ipAddress: string;\n}\n\n/**\n * Enum to describe the parsing status of a received packet, which was processed from the protocol handler.\n */\nexport enum ParsingStatus {\n    Ok = 1,\n    WrongHeader,\n    WrongVersion,\n    WrongIdSize,\n    ChecksumError,\n    Undefined,\n}\n\n/**\n * Model class which holds the parsed data together with the unique fan identifier and the status @see ParsingStatus.\n */\nexport class ParsedData {\n    /**\n     * Default constructor to initialize the data members.\n     */\n    constructor() {\n        this.strFanId = \"\";\n        this.status = ParsingStatus.Undefined;\n        this.receivedData = [];\n    }\n\n    strFanId: string;\n    status: ParsingStatus;\n    receivedData: IoBrokerDataPoint[];\n}\n\n/**\n * Model class to store the received data in a format, which can directly applied to the ioBroker states.\n */\nexport class IoBrokerDataPoint {\n    /**\n     * Constructor of the class.\n     *\n     * @param strIdentifer The unique identifier of the fan, to which the data belongs.\n     * @param value The data which can be written to an ioBroker state.\n     */\n    constructor(strIdentifer: string = \"\", value: ioBroker.StateValue = null) {\n        this.strIdentifer = strIdentifer;\n        this.value = value;\n    }\n\n    strIdentifer: string;\n    value: ioBroker.StateValue;\n}\n\n/**\n * Model class to store the received data in a format, which can directly applied to the ioBroker states.\n */\nexport class IoBrokerRewriteDataPoint extends IoBrokerDataPoint {\n    /**\n     * Constructor of the class.\n     *\n     * @param strIdentifer The unique identifier of the fan, to which the data belongs.\n     * @param value The data which can be written to an ioBroker state.\n     */\n    constructor(strIdentifer: string = \"\", value: ioBroker.StateValue = null) {\n        super(strIdentifer, value);\n        this.nRetryCount = 0;\n    }\n\n    nRetryCount: number;\n}\n\n/**\n * Model class which holds the necessary data for a remote endpoint together, to access it.\n */\nexport class FanRemoteEndpoint {\n    /**\n     * Constructor of the class.\n     *\n     * @param strIpAddress The IP address of the fan.\n     * @param strPassword The password of the fan for the protocol.\n     */\n    constructor(strIpAddress: string = \"\", strPassword: string) {\n        this.strIpAddress = strIpAddress;\n        this.strPassword = strPassword;\n    }\n\n    /**\n     * The IP address of the fan.\n     */\n    strIpAddress: string;\n\n    /**\n     * The password of the fan for the protocol.\n     */\n    strPassword: string;\n}\n\n/**\n * The data model which combines all necessary information from an ioBroker state and an fan, to create a protocol frame\n * to actually send the data to the frame.\n */\nexport class WriteDataModel {\n    /**\n     * Constructor of the class.\n     *\n     * @param strFanId The unique fan identifier.\n     * @param fanData The remote endpoint data to access the fan.\n     * @param strStateIdentifier The ioBroker related state identifier within the object tree.\n     * @param value The ioBroker state, which is requested to be written.\n     */\n    constructor(strFanId: string, fanData: FanRemoteEndpoint, strStateIdentifier: string, value: ioBroker.StateValue) {\n        this.strFanId = strFanId;\n        this.fanData = fanData;\n        this.strStateIdentifier = strStateIdentifier;\n        this.value = value;\n    }\n\n    strFanId: string;\n    fanData: FanRemoteEndpoint;\n    strStateIdentifier: string;\n    value: ioBroker.StateValue;\n}\n\ntype ParseResultFunction = (b: Buffer) => ioBroker.StateValue;\n\n/**\n * Model class to hold all necessary information together to create an ioBroker state in the object tree,\n * which is related to an data endpoint within a fan.\n */\nexport class FanData {\n    /**\n     * Constructor of the class.\n     *\n     * @param nSize The size of the state/parameter within the protocol in bytes.\n     * @param strIdentifer The unique identifier from the fan (16 hex chars).\n     * @param bIsReadable True means the parameter is readable from the fan, false means it can not be read.\n     * @param bIsWritable True means the parameter is writable towards the fan, false means it can not be written.\n     * @param strRole The role of the state within the object tree.\n     * @param strType The data type of the state within the object tree.\n     * @param name The name of the state within the object tree.\n     * @param parseFunction The function which is used to parse the received data into the ioBroker state value.\n     * @param strUnit The unit of the state, if available.\n     * @param minValue The minimum value of the state, if available (e.g. in case of a number).\n     * @param maxValue The maximum value of the state, if available (e.g. in case of a number).\n     */\n    constructor(\n        nSize: number,\n        strIdentifer: string,\n        bIsReadable: boolean,\n        bIsWritable: boolean,\n        strRole: string,\n        strType: ioBroker.CommonType,\n        name: ioBroker.StringOrTranslated,\n        parseFunction: ParseResultFunction,\n        strUnit?: string,\n        minValue?: number,\n        maxValue?: number,\n    ) {\n        this.nSize = nSize;\n        this.strIdentifer = strIdentifer;\n        this.bIsReadable = bIsReadable;\n        this.bIsWritable = bIsWritable;\n        this.strRole = strRole;\n        this.strType = strType;\n        this.strUnit = strUnit;\n        this.name = name;\n        this.parseFunction = parseFunction;\n        this.minValue = minValue;\n        this.maxValue = maxValue;\n    }\n\n    nSize: number;\n    strIdentifer: string;\n    bIsReadable: boolean;\n    bIsWritable: boolean;\n    strRole: string;\n    strType: ioBroker.CommonType;\n    name: ioBroker.StringOrTranslated;\n\n    parseFunction: ParseResultFunction;\n\n    strUnit: string | undefined;\n    minValue?: number | undefined;\n    maxValue?: number | undefined;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIO,MAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOb,YAAY,MAAc,WAAmB;AAChD,SAAK,OAAO;AACZ,SAAK,YAAY;AAAA,EACrB;AAAA,EAEO;AAAA,EACA;AACX;AAKO,IAAK,gBAAL,kBAAKA,mBAAL;AACH,EAAAA,8BAAA,QAAK,KAAL;AACA,EAAAA,8BAAA;AACA,EAAAA,8BAAA;AACA,EAAAA,8BAAA;AACA,EAAAA,8BAAA;AACA,EAAAA,8BAAA;AANQ,SAAAA;AAAA,GAAA;AAYL,MAAM,WAAW;AAAA;AAAA;AAAA;AAAA,EAIpB,cAAc;AACV,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,SAAK,eAAe,CAAC;AAAA,EACzB;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AACJ;AAKO,MAAM,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO3B,YAAY,eAAuB,IAAI,QAA6B,MAAM;AACtE,SAAK,eAAe;AACpB,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA;AAAA,EACA;AACJ;AAKO,MAAM,iCAAiC,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO5D,YAAY,eAAuB,IAAI,QAA6B,MAAM;AACtE,UAAM,cAAc,KAAK;AACzB,SAAK,cAAc;AAAA,EACvB;AAAA,EAEA;AACJ;AAKO,MAAM,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO3B,YAAY,eAAuB,IAAI,aAAqB;AACxD,SAAK,eAAe;AACpB,SAAK,cAAc;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA;AACJ;AAMO,MAAM,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASxB,YAAY,UAAkB,SAA4B,oBAA4B,OAA4B;AAC9G,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,qBAAqB;AAC1B,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAQO,MAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBjB,YACI,OACA,cACA,aACA,aACA,SACA,SACA,MACA,eACA,SACA,UACA,UACF;AACE,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,cAAc;AACnB,SAAK,cAAc;AACnB,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,OAAO;AACZ,SAAK,gBAAgB;AACrB,SAAK,WAAW;AAChB,SAAK,WAAW;AAAA,EACpB;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AACJ;",
  "names": ["ParsingStatus"]
}
